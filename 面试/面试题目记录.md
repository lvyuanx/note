# 面试题目记录

## 1、重写HashCode方法的作用？

hashcode用于返回对象的散列值，用于在散列函数中确定放置的桶的位置：

1. hashCode的存在主要是用于查找的快捷性，如Hashtable，HashMap等，hashCode是用来在散列存储结构中确定对象的存储地址的
2. 如果两个对象相同，就是适用于equals(java.lang.Object)方法，那么这两个对象的hashCode一定要相同
3. 如果对象的equals方法被重写，那么对象的hashCode也尽量重写，并且产生hashCode使用的对象，一定要和equals方法中使用的一致。否则与上述两点相悖
4. 两个对象的hashCode相同，并不一定表示两个对象就相同，也就是不一定适用于equal(java.lang.Object)方法，只能够说明这两个对象在散列存储结构中，如Hashtable，他们“存放在同一个篮子里”



## 2、为什么重写equals还要重写hashCode？

HashMap中，若比较key是否相等，要同时使用这两个函数。
因为自定义的类的hashcode()方法继承于Object类，其hashcode码为默认的内存地址，这样即使有相同含义的两个对象，比较也是不相等的。

* HashMap中比较key的方法：先求出key的hashcode()，比较其值是否相等，若相等再比较equals()，此时若相等则认为他们是相等的，若equals()不相等则认为他们是不相等的
* 若只重写hashcode()不重写equals()方法，当比较equals()时只是看他们是否为同一对象（即进行内存地址的比较），所以必定要两个方法一起重写
* HashMap用来判断key是否相等的方法：调用HashSet判断加入元素是否相等
  重载hashCode()是为了对同一个key，可以得到相同的hashCode，这样HashMap就可以定位到我们指定的key上；
  重载equals()是为了向HashMap表明当前对象和key上所保存的对象时相等的，这样我们才真正低获得了这个key所对用的这个键值对



## 3、重写equals方法的作用?

>Object类提供的 equals() 方法**默认是用 == 来进行比较**的，也就是说 只有两个对象是**同一个对象时，才能返回相等的结果** 。而实际的业务中，我们通常的需求是，若两个不同的对象它们的内容是相同的，就认为它们相等。鉴于这种情况，Object类中 equals() 方法的默认实现是没有实用价值的，所以通常都要重写。

```java
public boolean equals(Object obj) {
	return (this == obj);
}
```



## 4、List泛型为String类型如果添加类型为Integer类型的元素?

> AVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的**任意一个方法和属性**；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。

```java
ArrayList<String> list = new ArrayList<String>();
list.add("array");
//获得集合对象的Class类
Class cl =list.getClass();
//从集合Class类中获取add()方法 参数为object
Method method = cl.getMethod("add", Object.class);
//方法唤醒并调用 传入集合对象和需要存储的元素
method.invoke(list, 123);
method.invoke(list, 456);
method.invoke(list, 789);
System.out.println(list);
```



## 5、jvm对象创建过程？

1. `对象检查`：当Java虚拟机遇到一条字节码new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。
2. `对象创建`：类加载检查通过后，虚拟机为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定。（Java堆的内存分配：由于Java堆内存并不规则，已使用的、未使用的内存交杂在一起，没有办法简单进行“指针碰撞”，虚拟机必须维护一个列表，记录那些内存块可用。分配时就从列表中找到一块足够大的空间划分给对象实例，并更行列表记录。————“空闲列表（Free List）”）
3. `内存分配`：对象创建完毕后，虚拟机必须将分配到的内存空间都初始化为零值。保证了实例字段在Java代码中不实例化就直接使用，使程序能访问到这些字段的数据类型所对应的零值。
4. `对象设置`：例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码（实际上对象的哈希码会延后到真正调用Object::hashCode()方法时才计算）、对象的GC分代年龄等信息。这些信息存放在对象的对象头（Object Header）之中。



## 6、什么是索引？为什么要创建索引，mysql如何创建索引，创建索引的优缺点？

**1.是什么？**
    索引是**数据结构**，在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。
    ==以汉语字典的目录页（索引）打比方，我们可以通过拼音、笔画、偏旁部首等排序的目录（索引）快速查找到需要的字。==



**2.为什么？**

  在庞大的数据中检索时，合理使用索引能够大大的**提高数据查询效率**，这就是数据库引用索引技术的根本原因。



**3.怎么创建索引？**

创建索引有两种方式

1. 在建表的时候创建索引

   ```sql
   CREATE TABLE 表名(
   字段名 数据类型 [完整性约束条件],
          ……，
   [UNIQUE | FULLTEXT | SPATIAL] INDEX | KEY[索引名](字段名1 [(长度)] [ASC | DESC]) [USING 索引方法]
   );
   ```

2. 在建表后创建索引

   ```sql
   create index 索引名 on 表名(字段名)
   或者
   alter table  表名 add index(字段名)
   ```



**4.优缺点**
`优点`

* 索引大大减小了服务器需要扫描的数据量
* 索引可以帮助服务器避免排序和临时表
* 索引可以将随机IO变成顺序IO
* 索引对于InnoDB（对索引支持行级锁）非常重要，因为它可以让查询锁更少的元组。在MySQL5.1和更新的版本中，InnoDB可以在服务器端过滤掉行后就释放锁，但在早期的MySQL版本中，InnoDB直到事务提交时才会解锁。对不需要的元组的加锁，会增加锁的开销，降低并发性。 InnoDB仅对需要访问的元组加锁，而索引能够减少InnoDB访问的元组数。但是只有在存储引擎层过滤掉那些不需要的数据才能达到这种目的。一旦索引不允许InnoDB那样做（即索引达不到过滤的目的），MySQL服务器只能对InnoDB返回的数据进行WHERE操作，此时，已经无法避免对那些元组加锁了。如果查询不能使用索引，MySQL会进行全表扫描，并锁住每一个元组，不管是否真正需要。

`缺点`

* 虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存索引文件。
* 建立索引会占用磁盘空间的索引文件。一般情况这个问题不太严重，但如果你在一个大表上创建了多种组合索引，索引文件的会膨胀很快。
* 如果某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果。